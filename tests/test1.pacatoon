// TODO:
// * Get import working
// * Sort out semi-colon fussiness
// * Unit test operator (etc) precedence
//
// * Sort syntax for explicit type annotation
// * Type inference/propagation
//
// * AST simplification for LLVM output
// * FFI
//
// * Threading?

@def map fn l =
{
    @if (l == nil) nil
    @else (fn (head l)) :: (map fn (tail l))
};

@def foldLeft fn acc l =
{
    @if (l == nil) acc
    @else (fn (head l) (foldLeft fn acc (tail l)))
};
            
@def mergeSort l =
{
    @def elsAsLists l = map (@def _ x = x::nil) l;
    @def mergePair l1 l2 =
    {
        // Wouldn't it be nice to have pattern matching?
        @if ((l1 == nil) && (l2 == nil)) nil
        @else @if (l1 == nil) ((head l2) :: (mergePair l1 (tail l2)))
        @else @if (l2 == nil) ((head l1) :: (mergePair (tail l1) l2))
        @else @if ((head l1) < (head l2)) ((head l1) :: (mergePair (tail l1) l2))
        @else ((head l2) :: (mergePair l1 (tail l2)))
    };
    @def mergeAdjacentPairs l =
    {
        @if (l==nil) nil
        @else
        {
            @def first = head l;
            @def tail1 = tail l;
            @if ( tail1 == nil ) first :: nil
            @else (mergePair first (head tail1)) :: (mergeAdjacentPairs (tail tail1))
        }
    };
    @def mergeSortRec l = @if ((tail l) == nil) (head l) @else (mergeSortRec (mergeAdjacentPairs l));
    
    mergeSortRec (elsAsLists l)
};

// Am I allowed a comment?

@def reverse l =
{
    @def revrec l rl = @if (l==nil) rl @else revrec (tail l) ((head l)::rl);
    revrec l nil
};

//@def a : Integer = 12
//@def b : Float = 13.0
//@def sum (x : Integer) (y : Integer) : Integer = x + y

assertEqual (reverse (1.0::2.0::3.0::4.0::nil)) (4.0::3.0::2.0::1.0::nil);


@def a = 5::4::3::6::7::9::8::0::1::2::nil;
@def res = a;

assertEqual (mergeSort a) (0::1::2::3::4::5::6::7::8::9::nil);

@def divide x y = x / y;
@def fixedDivide x = (@def _ y = divide y x);
@def halve = fixedDivide 2.0;
@def third = fixedDivide 3.0;

assertEqual (halve 16.0) 8.0;
assertEqual (third 9.0) 3.0

